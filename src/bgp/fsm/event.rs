use super::error::NotificationError;
use crate::bgp::message::OpenMessage;

/// Administrative events from operator or configuration.
/// RFC 4271 Section 8.1.2 - Events 1-8.
///
/// Currently implemented:
/// - `ManualStart` (1): Used to start a session
/// - `ManualStop` (2): Used to stop a session gracefully
///
/// Not yet used:
/// - `AutomaticStart` (3): For auto-restart after failure
/// - `AutomaticStop` (8): For deconfiguration handling
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AdminEvent {
    /// Event 1: Manual start by operator.
    ManualStart,
    /// Event 2: Manual stop by operator.
    ManualStop,
    /// Event 3: Automatic start (e.g., on boot).
    AutomaticStart,
    /// Event 8: Automatic stop (e.g., deconfigured).
    AutomaticStop,
}

/// Timer expiration events.
/// RFC 4271 Section 8.1.2 - Events 9-13.
///
/// Currently implemented:
/// - `ConnectRetryTimerExpires` (9): Triggers connection retry
/// - `HoldTimerExpires` (10): Dead peer detection
/// - `KeepaliveTimerExpires` (11): Triggers KEEPALIVE send
///
/// Not yet implemented:
/// - `DelayOpenTimerExpires` (12): For delayed OPEN feature
/// - `IdleHoldTimerExpires` (13): For peer oscillation damping
#[allow(dead_code, clippy::enum_variant_names)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TimerEvent {
    /// Event 9: ConnectRetryTimer has expired.
    ConnectRetryTimerExpires,
    /// Event 10: HoldTimer has expired.
    HoldTimerExpires,
    /// Event 11: KeepaliveTimer has expired.
    KeepaliveTimerExpires,
    /// Event 12: DelayOpenTimer has expired (optional).
    DelayOpenTimerExpires,
    /// Event 13: IdleHoldTimer has expired (for peer oscillation damping).
    IdleHoldTimerExpires,
}

/// TCP connection events.
/// RFC 4271 Section 8.1.2 - Events 14-18.
///
/// Currently implemented:
/// - `TcpCrAcked` (16): Active open succeeded
/// - `TcpConnectionFails` (18): Connection error
///
/// Not implemented (requires passive mode):
/// - `TcpConnectionConfirmed` (17): For incoming connections
#[allow(dead_code, clippy::enum_variant_names)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TcpEvent {
    /// Event 16: TCP connection request acknowledged (active open succeeded).
    TcpCrAcked,
    /// Event 17: TCP connection confirmed (connection fully established).
    TcpConnectionConfirmed,
    /// Event 18: TCP connection fails.
    TcpConnectionFails,
}

/// BGP message received events.
/// RFC 4271 Section 8.1.2 - Events 19-28.
///
/// Currently implemented:
/// - `BgpOpen` (19): Valid OPEN message
/// - `BgpOpenMsgErr` (22): OPEN validation failed (generated by FSM)
/// - `NotifMsg` (24): NOTIFICATION received
/// - `KeepAliveMsg` (26): KEEPALIVE received
/// - `UpdateMsg` (27): UPDATE received (passed as raw bytes)
///
/// Not yet implemented:
/// - `BgpHeaderErr` (21): Header validation done in transport layer
/// - `UpdateMsgErr` (28): UPDATE validation not implemented
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MessageEvent {
    /// Event 19: Valid BGP OPEN message received.
    BgpOpen(OpenMessage),
    /// Event 21: BGP Header Error detected.
    BgpHeaderErr(NotificationError),
    /// Event 22: BGP OPEN message error detected.
    BgpOpenMsgErr(NotificationError),
    /// Event 24: NOTIFICATION message received.
    NotifMsg { code: u8, subcode: u8, data: Vec<u8> },
    /// Event 26: KEEPALIVE message received.
    KeepAliveMsg,
    /// Event 27: Valid UPDATE message received.
    UpdateMsg(Vec<u8>),
    /// Event 28: UPDATE message error detected.
    UpdateMsgErr(NotificationError),
}

/// All FSM events combined.
#[derive(Debug, Clone)]
pub enum FsmEvent {
    Admin(AdminEvent),
    Timer(TimerEvent),
    Tcp(TcpEvent),
    Message(MessageEvent),
}

impl From<AdminEvent> for FsmEvent {
    fn from(e: AdminEvent) -> Self {
        FsmEvent::Admin(e)
    }
}

impl From<TimerEvent> for FsmEvent {
    fn from(e: TimerEvent) -> Self {
        FsmEvent::Timer(e)
    }
}

impl From<TcpEvent> for FsmEvent {
    fn from(e: TcpEvent) -> Self {
        FsmEvent::Tcp(e)
    }
}

impl From<MessageEvent> for FsmEvent {
    fn from(e: MessageEvent) -> Self {
        FsmEvent::Message(e)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fsm_event_from_admin() {
        let event: FsmEvent = AdminEvent::ManualStart.into();
        assert!(matches!(event, FsmEvent::Admin(AdminEvent::ManualStart)));
    }

    #[test]
    fn test_fsm_event_from_timer() {
        let event: FsmEvent = TimerEvent::HoldTimerExpires.into();
        assert!(matches!(
            event,
            FsmEvent::Timer(TimerEvent::HoldTimerExpires)
        ));
    }

    #[test]
    fn test_fsm_event_from_tcp() {
        let event: FsmEvent = TcpEvent::TcpCrAcked.into();
        assert!(matches!(event, FsmEvent::Tcp(TcpEvent::TcpCrAcked)));
    }
}
